<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="description" content="Blog von Günther Jena (vormals Jehle)">
  <meta name="author" content="Günther Jena">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://www.semiversus.com/favicon.ico">
  <title>Statische Datenspeicher</title>
  <link href="https://www.semiversus.com/theme/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://www.semiversus.com/theme/css/font-awesome.min.css" rel="stylesheet">
  <link href="https://www.semiversus.com/theme/css/semiversus.css" rel="stylesheet">
  <link href="https://www.semiversus.com/theme/css/pygments.css" rel="stylesheet">
  <script src="https://www.semiversus.com/theme/js/jquery.min.js"></script>
  <script src="https://www.semiversus.com/theme/js/bootstrap.min.js"></script>
  <script data-isso="https://comments.semiversus.com" data-isso-vote="false" data-isso-lang="de" data-isso-reveal-on-click="true" src="https://www.semiversus.com/theme/js/embed.min.js"></script>
  <meta name="google-site-verification" content="O-3LVEziPiVrCYqFCwbLmB3s7lNG__cPMLLAr_RUxbA" />

    <script type= "text/javascript">
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['%%','%%'] ], " +
            "        processEscapes: false }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script>
</head>
<body data-spy="scroll" data-target="#sidebar" data-offset=30>
  <div id="wrap">
    <nav class="navbar navbar-inverse">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
          </button>
          <a href="https://www.semiversus.com/index.html" class="navbar-brand">SEMIVERSUS</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="https://www.semiversus.com/index.html">Blog</a></li>
            <li class="dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button">Unterricht<span class="carret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="https://www.semiversus.com/dic/uebersicht.html"><em>Übersicht</em></a></li>
                <li><a href="https://www.semiversus.com/dic/grundlagen_der_digitaltechnik/uebersicht.html">Grundlagen der Digitaltechnik</a></li>
                <li><a href="https://www.semiversus.com/dic/programmierbare_logik/uebersicht.html">Programmierbare Logik</a></li>
                <li><a href="https://www.semiversus.com/dic/mikrocontroller/uebersicht.html">Mikrocontroller</a></li>
                <li><a href="https://www.semiversus.com/dic/hardwarenahe_programmierung/uebersicht.html">Hardwarenahe Programmierung</a></li>
                <li><a href="https://www.semiversus.com/dic/halbleiterelemente/uebersicht.html">Halbleiterelemente</a></li>
                <li><a href="https://www.semiversus.com/dic/bussysteme/uebersicht.html">Bussysteme</a></li>
                <li><a href="https://www.semiversus.com/dic/rechnerarchitektur/uebersicht.html">Rechnerarchitektur</a></li>
                <li><a href="https://www.semiversus.com/dic/digitale_signalverarbeitung/uebersicht.html">Digitale Signalverarbeitung</a></li>
                <li><a href="https://www.semiversus.com/dic/komplexe_digitale_systeme/uebersicht.html">Komplexe digitale Systeme</a></li>
              </ul>
            </li>
            <li><a href="https://www.semiversus.com/projekte/projekte.html">Projekte</a></li>
            <li><a href="https://www.semiversus.com/about.html">Über mich</a></li>
          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li><a href="https://github.com/semiversus" class="social" data-toggle="tooltip" data-placement="bottom" title="Github.com/Semiversus"><span class="fa fa-github fa-2x"></span></a></li>
            <li><a href="http://stackoverflow.com/users/166605" class="social" data-toggle="tooltip" data-placement="bottom" title="Stackoverflow.com/Semiversus"><span class="fa fa-stack-overflow fa-2x"></span></a></li>
            <li><a href="https://www.semiversus.com/semiversus.atom.xml" class="social" data-toggle="tooltip" data-placement="bottom" title="RSS Feed"><span class="fa fa-rss fa-2x"></span></a></li>
          </ul>
        </div>
      </div>
    </nav>
    <div class="container">
    <div class="visible-print-block">Semiversus | Statische Datenspeicher</div>
<ol class="breadcrumb hidden-print"><li><a href="https://www.semiversus.com/dic/uebersicht.html">Digitale Systeme und Computersysteme</a></li><li><a href="https://www.semiversus.com/dic/halbleiterelemente/uebersicht.html">Halbleiterelemente</a></li><li><strong>Statische Datenspeicher</strong></li></ol>      <div class="row">
        <div class="col-md-8" role="main">
  <header><h1>Statische Datenspeicher<div class="pull-right hidden-print"><a href="https://www.semiversus.com/dic/halbleiterelemente/statische_datenspeicher.md"  class="btn btn-default btn-xs" data-toggle="tooltip" data-placement="bottom" title="Quelltext zu dieser Seite"><span class="fa fa-file-text-o fa-lg"></span></a></div></h1></header>
  <h1 id="allgemeines">Allgemeines</h1>
<p>Bei statischen Speichern wird keine zyklische Erneuerung der Information ben&ouml;tigt, da der Zustand in der Speicherzelle stabil gespeichert wird.</p>
<h1 id="festwertspeicher">Festwertspeicher</h1>
<h2 id="masken-rom">Masken ROM</h2>
<p>Bei einem Masken ROM (Read-Only-Memory) handelt es sich um einen Festwertspeicher, dessen Speicherinhalt durch den Fertigungsprozess &uuml;ber Masken fest angelegt wird. Diese Art von Speicher ist nur f&uuml;r sehr gro&szlig;e Massenfertigung sinnvoll, da die Erstellung von individuellen Masken sehr teuer ist. Die Anwendung muss auch so ausgelegt sein, dass es keine Notwendigkeit von nachtr&auml;glichen Updates gibt. F&uuml;r den Gro&szlig;teil der heutigen Endkundenprodukte ist so etwas unvorstellbar geworden.</p>
<p><img alt="ROM Speicherzelle" src="https://www.semiversus.com/dic/halbleiterelemente/rom.png"/></p>
<p>Die Ansteuerung erfolgt durch die Wort- und Datenleitung. Eine Speicherzelle wird selektiert, indem die Wortleitung auf logisch 1 gesetzt wird. Wenn die Verbindung durch die Maske erzeugt wurde, wird &uuml;ber diese Verbindung die Datenleitung auch auf logisch 1 gezogen. Die Datenleitung bleibt auf logisch 0, wenn die Verbindung nicht vorhanden ist.</p>
<p>Um ungewollte R&uuml;ckwirkungen zu vermeiden werden Dioden ben&ouml;tigt, da meist mehrere Speicherzellen gleichzeitig angesprochen werden. Die Wortleitung selbst wird durch einen Adressdekoder gesteuert.</p>
<p><img alt="ROM Adressdekoder" src="https://www.semiversus.com/dic/halbleiterelemente/rom_adressierung.png"/></p>
<h2 id="otp-rom">OTP ROM</h2>
<p>Beim OTP (One-Time-Programmable) ROM handelt es sich um eine Speicherstruktur die einmal programmierbar ist. Der Aufbau ist vergleichbar mit dem Masken ROM, nur hier ist jede Verbindung anfangs vorhanden. Jede Verbindung ist so ausgelegt, dass bei einem hohen Strom die Verbindung verdampft, &auml;hnlich einer Sicherung. So ist am Anfang jede Speicherzelle auf logisch 1 und kann durch den Schreibvorgang auf eine logisch 0 ge&auml;ndert werden. Dieser Vorgang ist jederzeit m&ouml;glich, die Umkehrung (logisch 0 auf 1) jedoch nicht.</p>
<h1 id="nicht-fluchtiger-speicher_1">Nicht-Fl&uuml;chtiger Speicher</h1>
<h2 id="eprom">EPROM</h2>
<p>Ein EPROM (Erasable Programmable ROM) ist ein Speicher, der gleich einem OTP ROM programmierbar ist. Der Speicherinhalt kann mittels UV-Licht gel&ouml;scht werden.</p>
<p><img alt="ROM Adressdekoder" src="https://www.semiversus.com/dic/halbleiterelemente/flash_zelle.png"/></p>
<h3 id="programmiervorgang">Programmiervorgang</h3>
<p><img alt="EPROM Beschaltung" src="https://www.semiversus.com/dic/halbleiterelemente/eprom.png"/></p>
<p>Beim Programmieren wird eine erh&ouml;hte Spannung (je nach Bauart zwischen 12 Volt und 25 Volt) angelegt. Dadurch kommt es zu einem Lawinen-Durchbruch (oder Avalanche-Durchbruch). Dadurch k&ouml;nnen Elektronen die d&uuml;nne Isolierschicht &uuml;berwinden und sich im Floating Gate sammeln.</p>
<p>Das Programmieren kann jederzeit wiederholt bzw. fortgesetzt werden, allerdings kann man nur Ladungen auf dem Floating Gate einbringen und diese nicht wieder abtransportieren.</p>
<p>Es wird meist zwischen zwei verschiedenen Programmieralgorithmen unterschieden. Beim langsamen Programmieren wird die maximale Programmierzeit, die der Herstellers des Bausteins angibt, verwendet. Dies kann je nach Hersteller zwischen einigen 100&micro;s bis einigen Millisekunden dauern. </p>
<p>Beim schnellen Programmieren werden wesentlich k&uuml;rzere Programmierzeiten verwendet (etwa 100&micro;s). Nach einem Programmiervorgang wird das Ergebnis zur&uuml;ckgelesen und sollten nicht genug Ladungen auf das Floating Gate gelangt sein, wird dieser Vorgang wiederholt. Nachdem das erste Mal das richtige Ergebnis zur&uuml;ckgelesen wird, wird ein etwas l&auml;ngerer Programmiervorgang gestartet (etwa 300&micro;s) um noch zus&auml;tzliche Ladungstr&auml;ger auf das Floating Gate zu bringen. Damit ist der Programmiervorgang f&uuml;r diese Zelle abgeschlossen.</p>
<h3 id="auslesen">Auslesen</h3>
<p>Der Transistor schaltet durch, wenn nun am Gate eine Spannung von etwa 5 Volt angelegt wird und das Floating Gate keine Ladungstr&auml;ger enth&auml;lt (wurde also nicht programmiert). Beim Durchschalten zieht der Transistor den Pegel der Datenleitung auf Massepotential. Wenn am Floating Gate Ladungstr&auml;ger vorhanden sind, verschiebt sich die Schwellenspannung und die 5 Volt am Gate reichen nicht mehr aus, den Transistor durchzuschalten. Der Pegel der Datenleitung wird also nicht auf Masse gezogen und bleibt auf einem hohen Pegel.</p>
<h3 id="loschen">L&ouml;schen</h3>
<p>Um nun die Information zu L&ouml;schen bzw. den Speicherbaustein auf seinen Auslieferungszustand zur&uuml;ckzusetzen wird nun mittels UV Licht im Bereich von 250nm der Widerstand der Isolierschicht heruntergesetzt und damit k&ouml;nnen die Elektronen Richtung Substrat abflie&szlig;en.</p>
<p>Damit dies &uuml;berhaupt m&ouml;glich wird, ist ein Quarzglas im Chip notwendig. Nach dem L&ouml;schen wird dies meist mit einem nicht transparenten Aufkleber abgedeckt.</p>
<figure><img src="https://www.semiversus.com/dic/halbleiterelemente/eprom.jpg"><figcaption>EPROM mit Quarzfenster (Bild: <a href="https://commons.wikimedia.org/wiki/File:16Mbit_EPROM_ST_Microelectronics_M27C160_(1).jpg">yellowcloud</a> CC BY 2.0)</figcaption></img></figure>
<p>Der L&ouml;schvorgang dauert je nach Intensit&auml;t zwischen 20 Minuten und mehreren Stunden. Da die Isolationsschicht sich bei jedem L&ouml;schvorgang verschlechtert geben die Hersteller meist eine Beschreibbarkeit (oder genauer L&ouml;schbarkeit) von einigen Hundert Zyklen an.</p>
<p>Da die Isolationsschicht nicht ideal isoliert flie&szlig;en &uuml;ber l&auml;ngere Zeit auch die Elektronen aus dem Floating Gate ab. Die Hersteller geben meist eine Zeit von ca. 10 Jahren an, in der ein EPROM seine Information behalten kann. Umwelteinfl&uuml;sse (erh&ouml;hte Umgebungstemperatur, R&ouml;ntgenstrahlung, ...) k&ouml;nnen diesen Vorgang beschleunigen.</p>
<h2 id="eeprom_1">EEPROM</h2>
<p>Eine EEPROM (Electrically-Erasable PROM) Speicherzelle ist im Prinzip &auml;hnlich wie ein EPROM aufgebaut. Die Isolationsschicht zwischen dem Floating Gate und Drain ist hier aber so d&uuml;nn, dass es auch bei geringen Spannungen von ca. 12 Volt zu einem sogenannten Tunneleffekt kommt. Dieser quantenmechanische Effekt erm&ouml;glicht das Durchwandern von Elektronen durch die d&uuml;nne Isolationsschicht in beide Richtungen. Es k&ouml;nnen also Elektronen auf das Floating Gate hinzugef&uuml;gt oder abgetragen werden.</p>
<p>Da der Transistor mit dem Floating Gate je nach gespeichertem Datum einen selbstsperrenden Zustand aufweisen kann, wird ein zweiter Transistor ben&ouml;tigt, um die Speicherzelle zu adressieren.</p>
<p>Ein Programmiervorgang ben&ouml;tigt je nach Typ zwischen 1ms und 10ms. Die Wiederbeschreibbarkeit liegt meist bei maximal 100.000 Schreibvorg&auml;ngen.</p>
<h2 id="flash">Flash</h2>
<p>Eine Flash Speicherzelle entspricht einer EEPROM Speicherzelle, nur wird hier durch eine &Auml;nderung der Schaltung nicht mehr jede Speicherzelle einzeln l&ouml;schbar. Die Speicherzellen werden zu sogenannten ''Pages'' zusammengefasst. Je nach Typ ist eine solche Page meist einige kByte gro&szlig;. Durch diese &Auml;nderung wird der zweite Transistor zur Adressierung nicht mehr ben&ouml;tigt und es kann somit eine h&ouml;here Speicherdichte erreicht werden.</p>
<p>Die Spannung zum Schreiben und L&ouml;schen (ca. 12V) wird heute meist durch integrierte Ladungspumpen realisiert. Die Beschreibbarkeit liegt meist bei einigen 100.000 Schreibvorg&auml;ngen.</p>
<h3 id="slc-vs-mlc">SLC vs. MLC</h3>
<p>In einer Single-Level-Cell wird nur zwischen vorhandener und nicht vorhandener Ladung (also logisch 0 oder 1) unterschieden. Wenn man nun mehrere Zwischenstufen nutzt, kommt man zur sogenannten Multi-Level-Cell. Wenn man zwischen 4 Ladungszust&auml;nden unterscheiden kann, k&ouml;nnen 2 Bit pro Speicherzelle gespeichert werden.</p>
<p>MLC Flash Speicher erh&ouml;hen die Speicherdichte (mehr Bit auf gleiche Fl&auml;che), die Transferrate (mehr Bit pro Zugriff). allerdings auch den Leistungsbedarf.</p>
<h1 id="fluchtiger-speicher_2">Fl&uuml;chtiger Speicher</h1>
<h2 id="sram">SRAM</h2>
<p><img alt="SRAM Zelle mit 6 Transistoren" src="https://www.semiversus.com/dic/halbleiterelemente/sram.png"/></p>
<p>SRAM Zellen werden heut meist mittels 6 Transistoren in einer CMOS Technologie gefertigt. Die Information wird in einer bistabilen Kippstufe (M1-M4) gespeichert. Die beiden Transistoren M5 und M6 dienen zum Adressieren der Speicherzelle. Um die gespeicherte Information auszulesen, werden die beiden Leitungen %%BL%% und %%\overline{BL}%% hochohmig gesetzt und die Transistoren M5 und M6 leiten. Dadurch ist der innere Zustand der Kippstufe auf den Leitungen %%BL%% und %%\overline{BL}%% lesbar.</p>
<p>Beim Schreiben werden die Leitungen %%BL%% und %%\overline{BL}%% entsprechend der zu speichernden Information gesetzt und die Speicherzelle mittels M5 und M6 adressiert. Der innere Zustand wird durch die Bitleitungen &uuml;berschrieben.</p>
<p>Eine Sonderform stellt eine SRAM Zelle mit 4 Transistoren dar. Dabei werden die beiden p-Kanal FETs durch Widerst&auml;nde ersetzt. Nachteilig ist die schlechte Fertigbarkeit in den heute &uuml;blichen Prozessen und der erh&ouml;hte Stromverbrauch.</p>
<h3 id="nvram">NVRAM</h3>
<p>Die hier beschriebene SRAM Zelle mit 6 Transistoren (oft kurz als 6T beschrieben) hat einen sehr kleinen Stromverbrauch (unter 1&micro;A Standby f&uuml;r einen 32KibiByte Speicher). Um aus einem SRAM einen nicht-fl&uuml;chtigen Speicher zu machen gibt es daher die M&ouml;glichkeit, den Speicher mit einer Bufferbatterie zu kombinieren. Dieser Speicher wird dann NVRAM (non-volatile random-acress-memory).</p>
        </div>
        <div class="col-md-4" role="complementary">
    <nav class="well well-sm" data-spy="affix" data-offset-top="0" id="sidebar">
    <ul class="nav"><li><a href="#allgemeines">Allgemeines</a></li><li><a href="#festwertspeicher">Festwertspeicher</a><ul class="nav"><li><a href="#masken-rom">Masken ROM</a></li><li><a href="#otp-rom">OTP ROM</a></li></ul></li><li><a href="#nicht-fluchtiger-speicher_1">Nicht-Fl&uuml;chtiger Speicher</a><ul class="nav"><li><a href="#eprom">EPROM</a><ul class="nav"><li><a href="#programmiervorgang">Programmiervorgang</a></li><li><a href="#auslesen">Auslesen</a></li><li><a href="#loschen">L&ouml;schen</a></li></ul></li><li><a href="#eeprom_1">EEPROM</a></li><li><a href="#flash">Flash</a><ul class="nav"><li><a href="#slc-vs-mlc">SLC vs. MLC</a></li></ul></li></ul></li><li><a href="#fluchtiger-speicher_2">Fl&uuml;chtiger Speicher</a><ul class="nav"><li><a href="#sram">SRAM</a><ul class="nav"><li><a href="#nvram">NVRAM</a></li></ul></li></ul></li></ul>
    </nav>
        </div>
      </div>
    </div>
  </div>
  <footer class="footer hidden-print"><div class="container"><p class="text-muted credit"><a href="http://creativecommons.org/licenses/by-sa/3.0/de/">CC-BY-SA</a> | Günther Jena 2011 - 2016 | Letztes Update am 4.5.2016 (Rev. <a href="https://github.com/semiversus/semiversus.github.io-source/commit/2cb1aa1">2cb1aa1</a>) <a href="https://plus.google.com/111972313670421914746/about" rel="author" class="hidden">Google+</a></p></div></footer>
</body>
</html>